<!DOCTYPE html>
<html style="background-color:#555"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>:: Play ::</title>
<script src="play/dataurls.js"></script>
<script src="play/three.min.js"></script>
<script src="play/PointerLockControls.js"></script>
<script src="play/CanvasRenderer.js"></script>
<script src="play/Projector.js"></script>
<script src="play/THREE.Terrain.min.js"></script>
<script type="text/javascript">

/*document.body.addEventListener("wheel", myFunction);

function myFunction() {
  console.log("35px");
}
*/

function openFullscreen() {
      //var elem = document.getElementById("id-webglcanvas");
      var elem = document.getElementsByTagName("canvas")[0];

      if (elem.requestFullscreen) {
        elem.requestFullscreen();
      } else if (elem.mozRequestFullScreen) { /* Firefox */
        elem.mozRequestFullScreen();
      } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) { /* IE/Edge */
        elem.msRequestFullscreen();
      }
      elem.style.width = '100%';
      elem.style.height = '100%';
    }

function animate() {

    requestAnimationFrame(animate);
    if (controls.isLocked === true) {

        raycaster.ray.origin.copy(controls.getObject().position);
        raycaster.ray.origin.y -= 10;

        var intersections = raycaster.intersectObjects(objects);
        var onObject = intersections.length > 0;
        var time = performance.now();
        var delta = (time - prevTime) / 1000;

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;
        velocity.y -= 9.8 * 100.0 * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        if (moveForward || moveBackward) velocity.z -= direction.z * 800.0 * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * 800.0 * delta;

        if (onObject === true) {
            velocity.y = Math.max(0, velocity.y);
            canJump = true;
        }

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
        controls.getObject().position.y += (velocity.y * delta);

        if (controls.getObject().position.y < -60) {
            velocity.y = 0;
            controls.getObject().position.y = -60;
            canJump = true;

        }
        prevTime = time;
    }}
    
var blocker = document.getElementById('blocker');
var instructions = document.getElementById('instructions');

var objects = [];
var raycaster;
var moveForward = false;
var moveBackward = false;
var moveLeft = false;
var moveRight = false;
var canJump = false;

var prevTime = performance.now();
var velocity = new THREE.Vector3();
var direction = new THREE.Vector3();
var vertex = new THREE.Vector3();
var color = new THREE.Color();

var VRButton = "";
var controls = "";

var camera, scene, renderer, clock, player, terrainScene, terrainPath, decoScene, lastOptions, fpsCamera, skyDome, skyLight, sand, water;


scene = new THREE.Scene();
renderer = new THREE.WebGLRenderer({
            //antialias: true
        });
aspr = 1.0;
camera = new THREE.PerspectiveCamera(50, aspr, 10, 11000);

function setup() {

//init();
render();
setupThreeJS();
setupWorld();

}

/*
function init() {
    // init three
    var canvas = document.createElement('canvas');

    
    var webGLContext = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

    if (window.WebGLRenderingContext && webGLContext && webGLContext.getShaderPrecisionFormat) {
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
    } else {
        renderer = new THREE.CanvasRenderer();
    }
    
    // viewport of WebGL
    renderer.setPixelRatio(window.devicePixelRatio);
    aspr = 1.0;
    var vpsizy = Math.min(window.innerWidth, window.innerHeight) - 50;
    var vpsizx = vpsizy * aspr
    renderer.setSize(vpsizx, vpsizy);

    //renderer.setPixelRatio(window.innerWidth/window.innerHeight);
    renderer.setSize(window.innerWidth, window.innerHeight);

    // background color
    renderer.setClearColor(0x606069, 1.0);

    // init scene
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(50, aspr, 10, 11000);

    //BACK 
    //camera.position.set(420, 30, 100);
    
    //scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xffffff, 0, 750);

    var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
    light.position.set(0.5, 1, 0.75);

    // init       
    light1 = new THREE.AmbientLight(0x666666); //1
    light2 = new THREE.DirectionalLight(0xffffff, 1.0); //2
    light2.position.set(10000, 10000, 5000); //3
    scene.add(camera, light, light2); //n

    //add sphere
    //camera.position.set(414,10,-177);

	var blocker = document.getElementById('blocker');
	var instructions = document.getElementById('instructions');

    instructions.addEventListener('click', function() {

        controls.lock();

    }, false);


    controls = new THREE.PointerLockControls(camera, renderer.domElement);
    controls.addEventListener('lock', function() {

        instructions.style.display = 'none';
        blocker.style.display = 'none';

    });

    controls.addEventListener('unlock', function() {

        blocker.style.display = 'block'; //block
        instructions.style.display = ''; //""

    });

    scene.add(controls.getObject());

    var onKeyDown = function(event) {

        switch (event.keyCode) {

            case 38: // up
            case 87: // w
                moveForward = true;
                break;

            case 37: // left
            case 65: // a
                moveLeft = true;
                break;

            case 40: // down
            case 83: // s
                moveBackward = true;
                break;

            case 39: // right
            case 68: // d
                moveRight = true;
                break;

            case 32: // space
                if (canJump === true) velocity.y += 350;
                canJump = false;
                break;

        }

    };

    var onKeyUp = function(event) {

        switch (event.keyCode) {

            case 38: // up
            case 87: // w
                moveForward = false;
                break;

            case 37: // left
            case 65: // a
                moveLeft = false;
                break;

            case 40: // down
            case 83: // s
                moveBackward = false;
                break;

            case 39: // right
            case 68: // d
                moveRight = false;
                break;

        }

    };

    document.addEventListener('keydown', onKeyDown, false);
    document.addEventListener('keyup', onKeyUp, false);

    raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);
*/
    // floor

    /*			var floorGeometry = new THREE.PlaneBufferGeometry( 2000, 2000, 100, 100 );
    				floorGeometry.rotateX( - Math.PI / 2 );

    				// vertex displacement

    				var position = floorGeometry.attributes.position;

    				for ( var i = 0, l = position.count; i < l; i ++ ) {

    					vertex.fromBufferAttribute( position, i );

    					vertex.x += Math.random() * 20 - 10;
    					vertex.y += Math.random() * 2;
    					vertex.z += Math.random() * 20 - 10;

    					position.setXYZ( i, vertex.x, vertex.y, vertex.z );

    				}

    				floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

    				position = floorGeometry.attributes.position;
    				var colors = [];

    				for ( var i = 0, l = position.count; i < l; i ++ ) {

    					color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
    					colors.push( color.r, color.g, color.b );

    				}

    				floorGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

    				var floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: true } );

    				var floor = new THREE.Mesh( floorGeometry, floorMaterial );
    				scene.add( floor );
    	  */

    // objects

    /*			var boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
			boxGeometry = boxGeometry.toNonIndexed(); // ensure each face has unique vertices

			position = boxGeometry.attributes.position;
			colors = [];

			for ( var i = 0, l = position.count; i < l; i ++ ) {

				color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
				colors.push( color.r, color.g, color.b );

			}

			boxGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

			for ( var i = 0; i < 500; i ++ ) {

				var boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: true } );
				boxMaterial.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

				var box = new THREE.Mesh( boxGeometry, boxMaterial );
				box.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
				box.position.y = Math.floor( Math.random() * 20 ) * 20 + 10;
				box.position.z = Math.floor( Math.random() * 20 - 10 ) * 20;

				scene.add( box );
				objects.push( box );

			}
*/

    // init controls : use OrbitControls.js
    //controls = new THREE.PointerLockControls(camera);

    //controls = new THREE.OrbitControls(camera, renderer.domElement);
    //controls.autoRotate = true;
    //controls.autoRotateSpeed = 0.3; 

    /*controls.userZoom = true;        
    controls.userZoomSpeed = 1.0;    
    controls.userRotate = true;      
    controls.userRotateSpeed = 1.0;  
    controls.userPan = true;         
    controls.userPanSpeed = 1.0;     
    controls.autoRotate = false;     
    controls.autoRotateSpeed = 2.0;  
    controls.minPolarAngle = 0; 
    controls.maxPolarAngle = Math.PI; 
    controls.minDistance = 0;        
    controls.maxDistance = Infinity; */

    // axis : use LineAxisHelper.js

    /* var sphere = new THREE.Mesh(new THREE.SphereGeometry(400,{ color: 0xff3300, side: THREE.DoubleSide } ));
    scene.add( sphere ); */


    /* MIN  axis = new THREE.AxisHelper(5000); 
     axis.position.set(0, 0, 0);
     scene.add(axis);
     */

    /* local materials
// init materials
var materials = [];


for(var i=0; i < mat.length; i++){
materials[i] = new THREE.MeshPhongMaterial();
//if (mat[i][2] == ""){
materials[i].color = new THREE.Color(mat[i][0]);
if (mat[i][1] < 1.0){
  materials[i].transparent = true;
  materials[i].opacity = 1.0 - mat[i][1];
}
materials[i].side = THREE.DoubleSide;
//}else{
if (mat[i][2] != ""){
// texture付material：      Load
var texture  = new THREE.ImageUtils.loadTexture(tex[i]);
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestFilter;
texture.wrapS = THREE.RepeatWrapping;
texture.wrapT = THREE.RepeatWrapping;
materials[i].map = texture;
materials[i].overdraw = true;
//materials[i].map.needsUpdate = true;
}
} */

    // init objects
    //objects = new THREE.Group();
/*        var geometry, vt, fc, mface;
    geometry = new THREE.Geometry();
    for (var j = 0; j < nv; j++) {
        vt = new THREE.Vector3(v[j][0], v[j][1], v[j][2]);
        geometry.vertices.push(vt);
    }
    for (var j = 0; j < nf; j++) {
        fc = new THREE.Face3(f[j][0], f[j][1], f[j][2], null, null, mati[j]);
        //fc.normal = new THREE.Vector3(v[f[j][0]][3], v[f[j][0]][4], v[f[j][0]][5]);
        geometry.faces.push(fc);
        // has_texture
         local materials
           if (mat[mati[j]][2] != ""){
             geometry.faceVertexUvs[0].push( [
               new THREE.Vector2(uv[j][0][0],uv[j][0][1]),
               new THREE.Vector2(uv[j][1][0],uv[j][1][1]),
               new THREE.Vector2(uv[j][2][0],uv[j][2][1])]  );
           }else{
             geometry.faceVertexUvs[0].push( [[0,0],[0,0],[0,0]] );
           }
           
    }
    geometry.computeFaceNormals();
    geometry.computeVertexNormals();
    */

    /* local materials 
    mface = new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials));
    scene.add( mface );
    */

    /*        mface = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0xff3300, side: THREE.DoubleSide } ));
    scene.add( mface ); */
/*
    mface = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
        color: 0xff2200
    }));
    scene.add(mface);
*/
    //scene.add( objects );

    //
 //   window.addEventListener('resize', onWindowResize, false);

    /* test frustum culling 
var frustum = new THREE.Frustum();
frustum.setFromMatrix( new THREE.Matrix4().multiply( camera.projectionMatrix, camera.matrixWorldInverse ) );

for (var i=0; i<objects.length; i++) {
objects[i].visible = frustum.intersectsObject( objects[i] );
} */
//        }
//
function setupThreeJS() {
scene = new THREE.Scene();
scene.background = new THREE.Color(0x555555);
//purple fog
scene.fog = new THREE.FogExp2(0x860081, 0.003);

water = new THREE.Mesh(
new THREE.PlaneBufferGeometry(16384+1024, 16384+1024, 16, 16),
new THREE.MeshLambertMaterial({color: 0x0055ff, transparent: true, opacity: 0.6})
);
water.position.y = -99;
water.rotation.x = -0.5 * Math.PI;

scene.add(water);

renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);

var blocker = document.getElementById('blocker');
var instructions = document.getElementById('instructions');
document.getElementById('scenes').appendChild(renderer.domElement);
//renderer.domElement.setAttribute('tabindex', -1);

camera = new THREE.PerspectiveCamera(60, renderer.domElement.width / renderer.domElement.height, 1, 10000);

//FRONT
//camera.position.set(606,50,500);
//camera.lookAt(new THREE.Vector3(150, 0, 0)); 

//BACK SWITCH
//camera.position.set(450,00,-425);
//camera.lookAt(new THREE.Vector3(-20, 0, 30));

//EXIT BOX LOCATION (TEASER)
camera.position.set(-202,-60,-331);
camera.lookAt(new THREE.Vector3(-450, -100, 850)); 
scene.add(camera);

var materialSphere01 = new THREE.MeshLambertMaterial({
        color: 0x0000ff,
        transparent: true,
        opacity: 0.5
    });
//var sphere02 = new THREE.Mesh(new THREE.SphereGeometry(400), materialSphere01);
  

clock = new THREE.Clock(false); 

var cube100 = new THREE.CubeGeometry( 100, 100, 100 );
var crateTexture = new THREE.ImageUtils.loadTexture( 'images/cbmerch01.png' );
//var crateTexture = new THREE.ImageUtils.loadTexture( 'forestdataurl' );

var crateMaterial = new THREE.MeshBasicMaterial( { map: crateTexture } );
	//var cbmerch01 = new THREE.Mesh( cube100.clone(), crateMaterial );
var cbmerch01 = new THREE.Mesh( cube100, crateMaterial );
	cbmerch01.position.set(-200,-60,-331);
	scene.add( cbmerch01 );

//cbmerch01.position.set(606,50,500);
	//scene.add( cbmerch01 );		

///CUSTOM BOX IMAGES////////////////////////////
/* create an array with six textures for a cool cube
	var materialArray = [];
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/Dice-Blue-1.png' ) }));
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/Dice-Blue-6.png' ) }));
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/Dice-Blue-2.png' ) }));
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/Dice-Blue-5.png' ) }));
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/Dice-Blue-3.png' ) }));
	materialArray.push(new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( 'images/Dice-Blue-4.png' ) }));
	var DiceBlueMaterial = new THREE.MeshFaceMaterial(materialArray);
	
	var DiceBlueGeom = new THREE.CubeGeometry( 85, 85, 85, 1, 1, 1 );
	var DiceBlue = new THREE.Mesh( DiceBlueGeom, DiceBlueMaterial );
	DiceBlue.position.set(60, 50, -100);
	scene.add( DiceBlue );	
*/

	// STAR//////////////
	
	var starPoints = [];
	
	starPoints.push( new THREE.Vector2 (   0,  50 ) );
	starPoints.push( new THREE.Vector2 (  10,  10 ) );
	starPoints.push( new THREE.Vector2 (  40,  10 ) );
	starPoints.push( new THREE.Vector2 (  20, -10 ) );
	starPoints.push( new THREE.Vector2 (  30, -50 ) );
	starPoints.push( new THREE.Vector2 (   0, -20 ) );
	starPoints.push( new THREE.Vector2 ( -30, -50 ) );
	starPoints.push( new THREE.Vector2 ( -20, -10 ) );
	starPoints.push( new THREE.Vector2 ( -40,  10 ) );
	starPoints.push( new THREE.Vector2 ( -10,  10 ) );
	
	var starShape = new THREE.Shape( starPoints );

	var extrusionSettings = {
		size: 5, height: 2, curveSegments: 3,
		bevelThickness: 1, bevelSize: 2, bevelEnabled: false,
		material: 0, extrudeMaterial: 1
	};
	
	var starGeometry = new THREE.ExtrudeGeometry( starShape, extrusionSettings );
	
var materialFront = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
var materialSide = new THREE.MeshBasicMaterial( { color: 0xff8800 } );
	var materialArray = [ materialFront, materialSide ];
	var starMaterial = new THREE.MeshFaceMaterial(materialArray);
	
var star = new THREE.Mesh( starGeometry, starMaterial );
	//var wireframeTexture = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } ); 
	//var star = new THREE.Mesh( starGeometry, wireframeTexture );
	star.position.set(0,50,0);
	scene.add(star);

// MERGE TEST//////////////////////////////////////////////////////////////////////

/* var gridXZ = new THREE.GridHelper(100, 10);
scene.add(gridXZ);

var dl = new THREE.SpotLight();
scene.add(dl);
dl.position.set(0, 50, 0);

scene.add(new THREE.AmbientLight(0x555555));
*/

// MERGING

var blueMaterial = new THREE.MeshPhongMaterial({
color: 0x0000FF
});
var redMaterial = new THREE.MeshPhongMaterial({
color: 0xFF0000
});

var boxGeometry = new THREE.BoxGeometry(10, 10, 10);

for (var face in boxGeometry.faces) {
boxGeometry.faces[face].materialIndex = 0;
}

var sphereGeometry = new THREE.SphereGeometry(5, 16, 16);
sphereGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 5, 0));

var mergeGeometry = new THREE.Geometry();
mergeGeometry.merge(boxGeometry, boxGeometry.matrix);
mergeGeometry.merge(sphereGeometry, sphereGeometry.matrix, 1);

var mesh = new THREE.Mesh(mergeGeometry, [blueMaterial, redMaterial]);
mesh.position.set(-202,60,-331);
scene.add(mesh);

var material = new THREE.MeshNormalMaterial();

var cubeGeometry = new THREE.CubeGeometry( 80, 80, 80 );
var cube = new THREE.Mesh( mesh, material );
	cube.position.set(-200,-60,-331);
//scene.add( cube );

//ADD OUTLINE for loop OR direct function ?
//purple
var outlineMaterial2 = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.BackSide } );
var outlineMesh2 = new THREE.Mesh( cubeGeometry, outlineMaterial2 );
	outlineMesh2.position = cube.position;
	outlineMesh2.scale.multiplyScalar(0.25);
	scene.add( outlineMesh2 );
//white
var outlineMaterial3 = new THREE.MeshBasicMaterial( { color: 0x860081, side: THREE.BackSide } );
var outlineMesh3 = new THREE.Mesh( cubeGeometry, outlineMaterial3 );
	outlineMesh3.position = cube.position;
	outlineMesh3.scale.multiplyScalar(0.2);
	scene.add( outlineMesh3 );

////////////////////////////////////////////////////////////////////////

var heightmapImage = new Image();
heightmapImage.src = mindataurl;

var grassImage = new Image();
grassImage.src = grassdataurl;

var grassTexture = new THREE.ImageUtils.loadTexture(forestdataurl);//was grassdataurl

// Remove a terrain
//scene.remove(terrainScene);

// Generate a terrain
var xS = 63, yS = 63;

terrainScene = THREE.Terrain({
easing: THREE.Terrain.Linear,
frequency: 2.5,
heightmap: heightmapImage,
//heightmap: customInfluences,
material: new THREE.MeshBasicMaterial({map:grassTexture}),
//material: new THREE.MeshBasicMaterial({color: 0xFF2200}),
map: grassImage,
maxHeight: 100,
minHeight: -100,
steps: 1,
useBufferGeometry: false,
xSegments: xS,
xSize: 1024,
ySegments: yS,
ySize: 1024,
});
scene.add(terrainScene);

//terrainPath//////////////////////////////////////////////////////
var pathImage = new Image();
pathImage.src = pathdataurl002;

//debug with :: pathdataurl002 : sanddataurl
var sandTexture = new THREE.ImageUtils.loadTexture(forestdataurl);// was sanddataurl

var xS = 40, yS = 40;
terrainPath = THREE.Terrain({
easing: THREE.Terrain.Linear,
frequency: 2.5,
heightmap: pathImage,
//heightmap: customInfluences,
material: new THREE.MeshBasicMaterial({map:sandTexture}),
//material: new THREE.MeshBasicMaterial({color: 0xFF2200}),
//map: grassImage,
maxHeight: 100,
minHeight: -100,
steps: 1,
useBufferGeometry: false,
xSegments: xS,
xSize: 1024,
ySegments: yS,
ySize: 1024,
});

terrainPath.position.y += 5;
scene.add(terrainPath);

//terrainPath instance??? //////////////////////////////////////////////////////
var pathImage = new Image();
pathImage.src = pathdataurl002;

//debug with :: pathdataurl002 : sanddataurl
var sandTexture = new THREE.ImageUtils.loadTexture(sanddataurl);


//LIGHT BLUE #798cb3 
//CORAL #ff7f50
var xS = 63, yS = 63;
terrainPath = THREE.Terrain({
easing: THREE.Terrain.Linear,
frequency: 1.5,
heightmap: pathImage,
//heightmap: customInfluences,
//material: new THREE.MeshBasicMaterial({map:sandTexture}),
//light off blue
material: new THREE.MeshBasicMaterial({color: 0x798cb3}),
//map: grassImage,
maxHeight: 100,
minHeight: -105,
steps: 1,
useBufferGeometry: false,
xSegments: xS,
xSize: 1024,
ySegments: yS,
ySize: 1024,
});

terrainPath.position.y += 5;
scene.add(terrainPath);

//terrainDeck//////////////////////////////////////////////////////


var deckImage = new Image();
deckImage.src = "data:image/png;base64,"+deckdataurl003;

//debug with :: deckdataurl : sanddataurl
var deckTexture = new THREE.ImageUtils.loadTexture(forestdataurl);

var xS = 63, yS = 63;
terrainDeck = THREE.Terrain({
easing: THREE.Terrain.Linear,
frequency: 12.5,
heightmap: deckImage,
//heightmap: customInfluences,
//material: new THREE.MeshBasicMaterial({map:deckTexture}),
material: new THREE.MeshBasicMaterial({color: 0x52361b}),
//map: grassImage,
maxHeight: -15,
minHeight: -112,
steps: 1,
useBufferGeometry: false,
xSegments: xS,
xSize: 1024,
ySegments: yS,
ySize: 1024,
});

terrainDeck.position.y += 11;

//terrainDeck.geometry = new THREE.BoxBufferGeometry(100,100,1000).toNonIndexed();

scene.add(terrainDeck);

//CLIPPING DECK ///////////////////////////////////////////////

//var localPlane = new THREE.Plane( new THREE.Vector3( 0, 0, 0 ), 1 );
//var globalPlane = new THREE.Plane( new THREE.Vector3( 0, 10, 0 ), 1 );
// ??? //globalPlane.material = new THREE.MeshBasicMaterial({color: 0xff0000});

//renderer.clippingPlanes = [ globalPlane ];
//renderer.localClippingEnabled = true;

/*
var material = new THREE.MeshNormalMaterial( {
clippingPlanes: [ localPlane ],
//clipShadows: true
} );
*/

/////////////////////////////////////////////////////////
//INTERESTING RAMP GOMETRY
/*
var xS = 63, yS = 1;
terrainDeck = THREE.Terrain({
easing: THREE.Terrain.Linear,
frequency: 2.5,
heightmap: deckImage,
//heightmap: customInfluences,
material: new THREE.MeshBasicMaterial({map:deckTexture}),
//material: new THREE.MeshBasicMaterial({color: 0xFF2200}),
//map: grassImage,
maxHeight: 50,
minHeight: -100,
steps: 1,
useBufferGeometry: false,
xSegments: xS,
xSize: 1024,
ySegments: yS,
ySize: 1024,
});
*/
//////////////////////////////////////////////////////////////////
// Optional:
// Get the geometry of the terrain across which you want to scatter meshes
var geo = terrainScene.children[0].geometry;
// Add randomly distributed foliage
decoScene = THREE.Terrain.ScatterMeshes(geo, {
mesh: new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 12, 6)),
w: xS,
h: yS,
spread: 0.02,
randomness: Math.random,
});

//terrainScene.add(decoScene);


// ADD BOXES AS LADDER ////////////////////////////////////////////////////////////////
var boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 200 ).toNonIndexed();

position = boxGeometry.attributes.position;

for ( let i = 0; i < 20; i ++ ) {

	const box = new THREE.Mesh( boxGeometry );
	box.position.x = 400 + Math.floor( Math.random() * 10 - 10 ) * 10;
	box.position.y = -100 + Math.floor( Math.random() * 10 ) * 10 + 10;
	//box.position.z = -200 + Math.floor( Math.random() * 10 - 10 ) * 10;

	scene.add( box );
	objects.push( box );

}

// DECK TEST //////////////////////////////////////////////////////////////
var geometry = new THREE.BoxBufferGeometry(100, 30, 500).toNonIndexed();
//var pos = geometry.attributes.position;
var material = new THREE.MeshBasicMaterial({color: 0x860081});
var cube = new THREE.Mesh(geometry, material);

cube.position.x =250;
cube.position.y =-20;
cube.position.z =0;

scene.add(cube);
objects.push( cube );

////////////////////////////////////////////////////////////////

instructions.addEventListener('click', function() {

        controls.lock();

    }, false);


    controls = new THREE.PointerLockControls(camera, renderer.domElement);
    controls.addEventListener('lock', function() {

        instructions.style.display = 'none';
        blocker.style.display = 'none';

    });

    controls.addEventListener('unlock', function() {

        blocker.style.display = 'block'; //block
        instructions.style.display = ''; //""

    });

    scene.add(controls.getObject());

    var onKeyDown = function(event) {

        switch (event.keyCode) {

            case 38: // up
            case 87: // w
                moveForward = true;
                break;

            case 37: // left
            case 65: // a
                moveLeft = true;
                break;

            case 40: // down
            case 83: // s
                moveBackward = true;
                break;

            case 39: // right
            case 68: // d
                moveRight = true;
                break;

	    case 46:// c
	    case 45:// x
	    case 44:// z
            case 32: // space
                if (canJump === true) velocity.y += 350;
                canJump = false;
                break;

        }

    };

    var onKeyUp = function(event) {

        switch (event.keyCode) {

            case 38: // up
            case 87: // w
                moveForward = false;
                break;

            case 37: // left
            case 65: // a
                moveLeft = false;
                break;

            case 40: // down
            case 83: // s
                moveBackward = false;
                break;

            case 39: // right
            case 68: // d
                moveRight = false;
                break;

        }

    };
	document.addEventListener('keydown', onKeyDown, false);
    	document.addEventListener('keyup', onKeyUp, false);

    raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);

/*           
    //////////////////////////BOXES//////////////////////////
    let floorGeometry = new THREE.PlaneBufferGeometry( 1000, 1000, 0, 0 );
			floorGeometry.rotateX( - Math.PI / 2 );

			// vertex displacement

			let position = floorGeometry.attributes.position;

			for ( let i = 0, l = position.count; i < l; i ++ ) {

				vertex.fromBufferAttribute( position, i );

				vertex.x += Math.random() * 20 - 10;
				vertex.y += Math.random() * 2;
				vertex.z += Math.random() * 20 - 10;

				position.setXYZ( i, vertex.x, vertex.y, vertex.z );

			}

			floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

			position = floorGeometry.attributes.position;
			const colorsFloor = [];

			for ( let i = 0, l = position.count; i < l; i ++ ) {

				color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
				colorsFloor.push( color.r, color.g, color.b );

			}

			//floorGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colorsFloor, 3 ) );

			const floorMaterial = new THREE.MeshBasicMaterial( { vertexColors: true } );

			const floor = new THREE.Mesh( floorGeometry, floorMaterial );
			//scene.add( floor );

			// objects

			const boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 ).toNonIndexed();

			position = boxGeometry.attributes.position;
			const colorsBox = [];

			for ( let i = 0, l = position.count; i < l; i ++ ) {

				color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
				colorsBox.push( color.r, color.g, color.b );

			}

			//boxGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colorsBox, 3 ) );

			for ( let i = 0; i < 100; i ++ ) {

				const boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: true } );
				boxMaterial.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

				const box = new THREE.Mesh( boxGeometry, boxMaterial );
				box.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
				box.position.y = Math.floor( Math.random() * 20 ) * 20 + 10;
				box.position.z = Math.floor( Math.random() * 20 - 10 ) * 20;

				//scene.add( box );
				objects.push( box );    
				}     
    */
    ////////////////// FLIP MESH

//var cubeGeometry = new THREE.CubeGeometry( 85, 85, 85 );
var geo = terrainScene.children[0].geometry;
var crate = new THREE.Mesh( geo.clone());
//crate.position.set(0, 0, 0);
//crate.rotation.set(0, 0, 0);
//crate.scale.set(-1, 0, -1);


//scene.add( crate );

//camera.position.set(-1000, 600, 400); 

flipMesh(crate);
//scene.add(crate);

/* 
var scale = new THREE.Vector3(1, 1, 1);
if (this.flipY) {
scale.y *= -1;
}
if (this.flipZ) {
scale.z = -1;
}
crate2.scale.multiply(scale);

scene.add(crate2);

*/
// Add Terrain

}

function flipMesh(object3D) {

object3D.applyMatrix(new THREE.Matrix4().makeScale(-1, 1, 1));
reverseWindingOrder(object3D);
}

function reverseWindingOrder(object3D) {

// TODO: Something is missing, the objects are flipped alright but the light reflection on them is somehow broken

if (object3D.type === "Mesh") {

var geometry = object3D.geometry;

for (var i = 0, l = geometry.faces.length; i < l; i++) {

    var face = geometry.faces[i];
    var temp = face.a;
    face.a = face.c;
    face.c = temp;

}

var faceVertexUvs = geometry.faceVertexUvs[0];
for (i = 0, l = faceVertexUvs.length; i < l; i++) {

    var vector2 = faceVertexUvs[i][0];
    faceVertexUvs[i][0] = faceVertexUvs[i][2];
    faceVertexUvs[i][2] = vector2;
}

geometry.computeFaceNormals();
geometry.computeVertexNormals();
}

if (object3D.children) {

for (var j = 0, jl = object3D.children.length; j < jl; j++) {

    reverseWindingOrder(object3D.children[j]);
}
}
}


/////////////////////////////////////////////////////////////////////////////////////////////

//water = new THREE.Mesh(
new THREE.PlaneBufferGeometry(16384+1024, 16384+1024, 16, 16),
//new THREE.MeshLambertMaterial({color: 0x0055ff, transparent: false, opacity: 0.6});
//water.position.y = -99;
//water.rotation.x = -0.5 * Math.PI;
//scene.add(water);
//} 

animate();

function render() {
    requestAnimationFrame(render);
    //controls.update();
    //scene.add(controls.getObject());
    renderer.render(scene, camera);
}
</script>
</head>

<body onload="setup();">
<div id="scenes">
<div id="blocker" style="display: block;">
<div id="instructions" style="text-align: center;">
<span id="play" style="font-size:36px;color:LIGHTCORAL;cursor:pointer;text-decoration: underline;">:: Play :: </span>

<span id="playfullscreen" onClick="openFullscreen();" style="font-size:36px;color:LIGHTBLUE;cursor:pointer;text-decoration: underline;">:: Play :: </span>

<!-- video intro information :: Move: WASD<br>
Jump: SPACE<br>
Look: MOUSE 
</div>
</div>
<canvas id="id-webglcanvas"  style="width: 1280px; height: 431px;" width="1280" height="431"></canvas>

</div>
 
<div> 
<span id="learn" style="font-size:36px;color:LIGHTCORAL;cursor:pointer;text-decoration: underline;">:: Learn :: </span>

<span id="learnfullscreen" style="font-size:36px;color:LIGHTBLUE;cursor:pointer;text-decoration: underline;">:: Learn :: </span>
<canvas style="width: 1280px; height: 431px;" width="1280"
</div>

<div> 
<span id="action" style="font-size:36px;color:LIGHTCORAL;cursor:pointer;text-decoration: underline;">:: Action:: </span>

<span id="actionfullscreen" style="font-size:36px;color:LIGHTBLUE;cursor:pointer;text-decoration: underline;">:: Action :: </span>
<canvas style="width: 1280px; height: 431px;" width="1280"
</div>
-->
</body></html>